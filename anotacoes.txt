Atributos na classe pessoa seriam o nome e a idade

já apresentar seria um método

ecapsulamento é proteger os nossos atributos de modificações externas, a não ser que ela passe por validações seja de propriedades ou de métodos

quando é uma validação muito simples é preferível que faça:
get => _nome.ToUpper();
que é uma body expression

public todo mundo pode acessar
private só a própria classe pode acessar e alterar

um campo não terá get e set
propriedade vão ter get e/ou set

propriedade só de get:
public string NomeCompleto => $"{Nome} {Sobrenome}";
com body expression

public void AdicionarAluno(Pessoa aluno)
{
    Alunos.Add(aluno);
}
método que recebe um Objeto, void pois não retorna nada

método com retorno:
public int ObterQuantidadeAlunosMatriculados()
{
    int quantidade = Alunos.Count;
    return quantidade;
}

Usando construtores a criação de um objeto fica bem mais fácil:
Pessoa p1 = new Pessoa("Helo", "Giacometti", 20);
Pessoa p2 = new Pessoa("Leonardo", "Buta", 23);

Para ficar mais claro pra quem lê dá para deixar:
Pessoa p1 = new Pessoa(nome: "Helo", sobrenome: "Giacometti", idade: 20);
Pessoa p2 = new Pessoa(nome: "Leonardo", sobrenome: "Buta", idade: 23);

Concatenação: string texto = "Nº " + count + " - " + Alunos[count].NomeCompleto;

Interpolação: string texto = $"Nº  {count} - {Alunos[count].NomeCompleto}";
para interpolação precisa do símbolo de dólar antes das aspas duplas, deixa mais clara manipulação de texto, mais fácil de visualizar

Concatenação de strings com "+":
string texto1 = "10";
string texto2 = "20";
string texto3 = texto1 + texto2;
texto3 vai ser igual a "1020"
se quiser a soma de fato tem que converter para inteiro

string texto1 = "10";
int texto2 = 20;
string texto3 = texto1 + texto2;
quando tem uma string e um inteiro, e a string aparece primeiro
ele faz um casting implícito onde o int vira string
tem sinal de + e tem uma string, tudo vai virar string


Formatação de valores monetários 
decimal valorMonetario = 82.40M;
Console.WriteLine($"{valorMonetario:C}");
O "C" significa currency daí ele formata conforme a nossa moeda
Ele pega essa informação da configuração do seu sistema
Se utilizar em uma nuvem vai ser dólar ou de onde está a nuvem
Se eu quiser mudar a cultura e deixar ela para todo o sistema basta fazer o seguinte código:
CultureInfo.DefaultThreadCurrentCulture = new CultureInfo("en-US");
Mesmo que a minha esteja em pt-BR consigo formatar diferente na hora de formatar:
Console.WriteLine(valorMonetario.ToString("C", CultureInfo.CreateSpecificCulture("en-US")));

Console.WriteLine(valorMonetario.ToString("C8"));
-> mostra a moeda de acordo com a culture encontrada + 8 casas decimais

Console.WriteLine(valorMonetario.ToString("N8"));
-> não mostra a moeda de acordo com a culture encontrada mas mostra as 8 casas decimais

Formatação para porcentagem:
double porcentagem = .3421;
Console.WriteLine(porcentagem.ToString("P"));

Formatação dos valores conforme quiser:
int numero = 123456;
Console.WriteLine(numero.ToString("##-##-##"));
Resultado: 12-34-56

DateTime data = DateTime.Now;
cuidado quando usar isso em nuvem pois irá pegar essa informação de lá

Data é muito importante principalmente quando mexemos também com banco de dados
Console.WriteLine(data.ToString("dd/MM/yyyy"));
MM é de mês
mm é de minutos

Console.WriteLine(data.ToString("dd/MM/yyyy HH:mm"));
HH é de horas contando até 24
hh é de horas contando até 12
DateTime é muito bom pois pode formatar do jeito que mais atende ao seu problema
.ToString() → mostra tudo (data e hora).
.ToShortDateString() → mostra só a data.
.ToShortTimeString() → mostra só a hora.

Transformação de string em data sem parar o sistema caso não seja possível converter:

string stringData = "2022-04-17 18:00";
DateTime.TryParseExact(stringData, "yyyy-MM-dd HH:mm", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dataConvertidaDaString);

Console.WriteLine(dataConvertidaDaString);

Quando ocorre uma exceção, a execução interrompe e o controle é dado ao manipulador de exceção apropriado. Isso geralmente significa que as linhas de código que você espera que sejam executadas são ignoradas. Alguma limpeza de recursos, como fechar um arquivo, precisa ser feita mesmo se uma exceção for gerada. Para fazer isso, você pode usar um finally bloco. Um finally bloco sempre é executado, independentemente de uma exceção ser gerada.


No exemplo:
public void Metodo1()
        {
            Metodo2();
        }
        public void Metodo2()
        {
            Metodo3();
        }
        public void Metodo3()
        {
            Metodo4();
        }
        public void Metodo4()
        {
            throw new Exception("Ocorreu ma exceção");
        }
a exceção não é tratada, então o programa é encerrado, vai voltando até tentar encontrar o try catch
Se não encontra, mostra o rastro que ele fez até encontrar o erro

Para criar uma fila:
Queue<int> fila = new Queue<int>();

Para inserir na fila:
fila.Enqueue(2);
fila.Enqueue(4);
fila.Enqueue(6);
fila.Enqueue(8);

Para remover o item da fila seguindo FIFO:
fila.Dequeue();

Para criar uma pilha:
Stack<int> pilha = new Stack<int>();

Para inserir na pilha:
pilha.Push(4);
pilha.Push(6);
pilha.Push(8);
pilha.Push(10);

Para remover o item da pilha seguindo LIFO:
pilha.Dequeue();